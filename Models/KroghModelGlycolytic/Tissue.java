package Models.KroghModelGlycolytic;import Framework.GridsAndAgents.AgentGrid2D;import Framework.GridsAndAgents.AgentSQ2Dunstackable;import Framework.GridsAndAgents.PDEGrid2D;import Framework.Gui.GuiGridVis;import Framework.Gui.GuiLabel;import Framework.Gui.GuiWindow;import Framework.Interfaces.AgentToColorInt;import Framework.Tools.FileIO;import Framework.Gui.TickTimer;import Framework.Utils;import java.util.Random;import static Models.KroghModelGlycolytic.Tissue.*;import static Framework.Utils.*;/** * Created by Rafael on 8/1/2017. */class Cell extends AgentSQ2Dunstackable<Tissue> {    double vesselO2;    double vesselGlu;    double vesselProton;    double O2Consumed;    double GluConsumed;    double cycleTime;    double O2ConsumedProl;    double death_decision;    double ProtonProduced;    double birth_decision;    double MaxGluRate;    double necro;    double cellCycleReq;    double ATPconsumed;    double glycoPhenotype;    double ResistAcid;    double maxATP;    double currentATP;    int IDIE;    double atp;    double nat_death_prob;    double birth_thr;    double O2Conc;    double GluConc;    void Init(boolean isVessel,double glycoPhenotype, boolean isNecrotic, double currentATP, double cellCycleReq){        if(isVessel){            this.vesselO2 = G().Blood_TurnOnOff_O2();            this.vesselProton = G().BloodTurnOnOff_Proton();            this.vesselGlu = G().Blood_TurnOnOff_GLU();            this.necro=-1;        }        else if(isNecrotic){            this.vesselO2 =-1;            this.glycoPhenotype=glycoPhenotype;            this.vesselGlu=-1;            this.vesselProton=-1;            this.necro = 100;            G().popNecro++;        }        else{            this.glycoPhenotype=glycoPhenotype;            this.vesselO2 =-1;            this.vesselGlu=-1;            this.currentATP=currentATP;            this.vesselProton=-1;            this.necro=-1;            this.cellCycleReq= (G().AVG_CELL_CYCLE + G().rn.nextDouble()*G().AVG_CELL_CYCLE)*G().DIFFs_IN_DAY*G().ATP_TARGET;            PlusCell();        }    }    void PlusCell(){        if (IsMut()){            G().popTumor++;        }        else{            G().popNormal++;        }    }    void MinusCell(){        if (IsMut()){            G().popTumor--;        }        else{            G().popNormal--;        }    }    boolean IsMut() {        return glycoPhenotype == G().MUTANT_GLYCOLYTIC_PHENO;    }    void ApoptoticDeath(){        if(!IsVessel()) {            if (IsMut()) {                G().popTumor--;            } else {                G().popNormal--;            }        }        Dispose();    }    void ConvertToNecrotic(){        this.Init(false, glycoPhenotype,true,currentATP, cellCycleReq);        if (IsMut()) {            G().popTumor--;        }        else {            G().popNormal--;        }    }    boolean IsNecrotic(){        return necro!= -1;    }    boolean IsVessel(){        return vesselO2 !=-1;    }    void DiffStep(){        //vessel production        if(IsVessel()) {            if (G().Blood_TurnOnOff_O2() != 0) {                G().O2.Set(Isq(), G().Blood_TurnOnOff_O2());                G().Glu.Set(Isq(), G().Blood_TurnOnOff_GLU());                G().proton.Set(Isq(), G().BloodTurnOnOff_Proton());            }        }        //cell consumption        else if (!IsNecrotic() && !IsVessel()){            double O2Conc=G().O2.Get(Isq());            double GluConc = G().Glu.Get(Isq());            O2Consumed=-MichaelisMenten(O2Conc,G().O2_MAX_RATE,G().O2_HALF_MAX);            MaxGluRate = glycoPhenotype*G().ATP_TARGET /2.0f + 27.0f*(O2Consumed)/10.0f;            //if(MaxGluRate<0){            //    throw new IllegalStateException("MaxGlu< < 0");            //}            GluConsumed=-MichaelisMenten(GluConc, MaxGluRate, G().GLU_HALF_MAX);            ProtonProduced = G().PROTON_BUFF_COEF *(29.0f*(glycoPhenotype*G().O2_MAX_RATE + O2Consumed)/5.0f);            G().Glu.Add(Isq(),GluConsumed);            G().O2.Add(Isq(),O2Consumed);            G().proton.Add(Isq(), ProtonProduced);            //if(G().O2.GetCurr(Isq())<0){            //    throw new IllegalStateException("Cell consuming more O2 than exists");            //}            //}        }    }    double PhenoFlip(){        double FlipProb = G().rn.nextDouble();        double OldPheno = glycoPhenotype;        double O2level=G().O2.Get(Isq())/G().VESSEL_O2_VAL;        //System.out.println(OldPheno );        if ( O2level < 0.3){            if (FlipProb < 0.5f) {                //System.out.println("Flip");                if (G().PHENO_CHOICE[1] == glycoPhenotype) {                    glycoPhenotype = G().PHENO_CHOICE[0];                    //System.out.println("Flip1 " + glycoPhenotype + "," +OldPheno);                }                else if (G().PHENO_CHOICE[0] == glycoPhenotype) {                    glycoPhenotype = G().PHENO_CHOICE[1];                    //System.out.println("Flip2 " + glycoPhenotype + "," +OldPheno);                }            }        }        //System.out.println(glycoPhenotype);        return glycoPhenotype;    }    void CheckForDeath(double pH){        if (Alive() && G().rn.nextDouble() <= G().NORMAL_DEATH_RATE) {            ApoptoticDeath();            MinusCell();            return;        }        AcidResistance();        if (Alive() && pH < ResistAcid && PoorCondDeathProb()) {            ApoptoticDeath();            MinusCell();            return;        }    }    boolean PoorCondDeathProb() {        death_decision = G().rn.nextDouble();        double deathprob;        if (G().GetTick() < 500){            deathprob = 0.14;        }        else{            deathprob = G().POOR_COND_DEATH_RATE;        }        if (death_decision <= deathprob) {            return true;        }        else{            return false;        }    }    double AcidResistance(){        if(IsMut()){            ResistAcid = G().MUTANT_ACID_RESIST;        }        else{            ResistAcid = G().NORMAL_ACID_RESIST;        }        return ResistAcid;    }    double ATP_COSTS_Divide_Req() {        if (IsMut()) {            return cellCycleReq*4.0;        }        else{            return cellCycleReq;}    }    void Step(){        if (!IsVessel() && !IsNecrotic()) {            double pH = ProtonsToPh(G().proton.Get(Isq()));            CheckForDeath(pH);            double atp_per_timestep = -(2.0f * GluConsumed + 27.0f * O2Consumed / 5.0f)*G().DIFFs_IN_TIME_STEP;            currentATP += atp_per_timestep;            double normATP = atp_per_timestep/G().ATP_TARGET_PER_DIFFSTEP;            double normTotalATP = currentATP/ATP_COSTS_Divide_Req();            if (Alive())                if (normATP <= G().ATP_DEATH_THR && PoorCondDeathProb()) {                    ConvertToNecrotic();                    MinusCell();                }                else if(normTotalATP>= G().ATP_QUIES_THR){                    int nValidIs = G().HoodToEmptyIs(G().mooreHood, G().validDivIs, Xsq(), Ysq());                    if (nValidIs > 0) {                        currentATP = 0;                        int daughterI = G().validDivIs[G().rn.nextInt(nValidIs)];                        Cell daughter = G().NewAgentSQ(daughterI);                        //PhenoFlip();                        daughter.Init(false, glycoPhenotype, false,0.0,0.0);                        Init(false, glycoPhenotype, false,0.0,0.0);                    }                }        }        else if (IsVessel()) {           //hgckf        }        else if(IsNecrotic()){            double necroProb = G().rn.nextDouble();            double necro_die;            if (G().GetTick() < 50){               necro_die = 0.0001;            }            else{                necro_die = 1.e-4;            }            if (necroProb < necro_die){                Dispose();                G().popNecro--;            }        }    }}public class Tissue extends AgentGrid2D<Cell> {    FileIO out;    FileIO out2;    FileIO out3;    //TIMESCALES & GRID SPACING    static int SIDE_LEN=60;    static int TIMESTEPS=5000000;    static int STEP_PAUSE= 1;//(int) Math.round((16*60*60)/0.6);    final long tickRate = 0;    static int VIS_SCALE=10;    //TIMES    public double DIFF_TIME_STEP = 0.02f;       //[s]    double TIME_STEP = 0.2;                        // [days]    double DIFFs_IN_TIME_STEP = 864000.0f;    double AVG_CELL_CYCLE = 0.8;    public static int TIMESTEPS_IN_CYCLE = 1000;//720000; 180000;    double DIFFs_IN_DAY = 4320000;    TickTimer trt;    //OXYGEN CONSUMPTION    double O2_MAX_RATE =0.012f * DIFF_TIME_STEP;       // [mmol/L]    double O2_HALF_MAX =0.005f;                   // [mmol/L]    double CELL_CONSUMPTION_2_DIVIDE=0.05f;                         // [mmol/L]    //O2 CONCENTRATION CHECKPOINTS    double NECROSIS_O2 =0.001f;                                    // [mmol/L]    double Q_THRESHOLD = 0.0056f;                                  // [mmol/L]    double VESSEL_O2_VAL = 0.056f;                                      // [mmol/L]    //GLUCOSE VALUES    double GLU_HALF_MAX = 0.04f;                                    // [mmol/L]    double GLU_DIFF = 0.1f;    double VESSEL_GLU_VAL = 5.0f;                                       // [mmol/L]    double ATP_TARGET = 29.0f* O2_MAX_RATE /5.0f;    double ATP_TARGET_PER_DIFFSTEP = ATP_TARGET *DIFFs_IN_TIME_STEP;    //ACID    double PROTON_BUFF_COEF =3.0e-5;    double NORMAL_ACID_RESIST = 6.65f;                       // [pH]    double VESSEL_PH_VAL = 7.4f;                             // [pH]    double MUTANT_ACID_RESIST = 6.61f;    //PHENOTYPES    double MUTANT_GLYCOLYTIC_PHENO=2;    double NORMAL_GLYCOLYTIC_PHENO=1;    double[] PHENO_CHOICE = {NORMAL_GLYCOLYTIC_PHENO, MUTANT_GLYCOLYTIC_PHENO};    //ATP THRESHOLDS    double ATP_DEATH_THR = 0.3;    double ATP_QUIES_THR = 0.8;    //COUNTING    double popNormal=0;    double popTumor=0;    double popNecro=0;    //DEATH PROBABILITIES    double NORMAL_DEATH_RATE = 0.001f;                  //[per cell cycle]    double POOR_COND_DEATH_RATE = 0.14f;//0.47    double NECROTIC_TURNOVER;    double STEADY_STATE_REQ=0.00001;    int TURN_OFF_TICK = 100;    FileIO atpTestOut;    PDEGrid2D O2;    PDEGrid2D Glu;    PDEGrid2D proton;    Random rn;    TissueVis vis;    int[] mooreHood=MooreHood(false);    int[] validDivIs=new int[mooreHood.length/2];    public Tissue(int x,int y,String outFileName, String outFile2, String outFile3){        super(x,y,Cell.class);        out=new FileIO(outFileName,"w");        out2=new FileIO(outFile2,"w");        atpTestOut=new FileIO("atpTestOutON.csv","w");        out3=new FileIO(outFile3,"w");        O2=new PDEGrid2D(xDim,yDim);        Glu = new PDEGrid2D(xDim, yDim);        proton = new PDEGrid2D(xDim, yDim);        rn=new Random();        vis =new TissueVis(this);        trt=new TickTimer();        AddVessel(xDim*4/12, yDim*4/12);        AddVessel(xDim*6/12, yDim*4/12);        AddVessel(xDim*8/12, yDim*4/12);        AddVessel(xDim*4/12, yDim*6/12);        AddVessel(xDim*6/12, yDim*6/12);        AddVessel(xDim*8/12, yDim*6/12);        AddVessel(xDim*4/12, yDim*8/12);        AddVessel(xDim*6/12, yDim*8/12);        AddVessel(xDim*8/12, yDim*8/12);        //AddVessel(xDim*4/12, yDim*10/12);        //AddVessel(xDim*6/12, yDim*10/12);        //AddVessel(xDim*8/12, yDim*10/12);        //FillTissue();        FillCircle(xDim*6/12, yDim*6/12);        IncTick();        //for (int i = 0; i < 100; i++) {        //    Metabolism();        //}        DiffToSteadyState(STEADY_STATE_REQ);    }    void AddVessel(int x,int y){        Cell Vessel=NewAgentSQ(x,y);        Vessel.Init(true,0.0, false, 0.0, 0.0);    }    void FillTissue(){        for (int i = 0; i < length; i++) {            if(GetAgent(i)==null) {                Cell c = NewAgentSQ(i);                double glycoPheno = NORMAL_GLYCOLYTIC_PHENO;                if (rn.nextDouble() < 0.5) {                    glycoPheno = MUTANT_GLYCOLYTIC_PHENO;                }                c.Init(false, glycoPheno, false, 0.0, 0.0);            }        }    }    void GenVesselAndCells(int centerX,int centerY,double radius){        //get cell starting indices        int[] startPopSquares= CircleHood(false,radius);        int[] startPopIs=new int[startPopSquares.length/2];        int nNewCells=this.HoodToEmptyIs(startPopSquares,startPopIs,centerX,centerY);        //create vessel        AddVessel(centerX,centerY);        //create cells        for (int i = 0; i < nNewCells; i++) {            Cell c=NewAgentSQ(startPopIs[i]);            double glycoPheno=NORMAL_GLYCOLYTIC_PHENO;            if(rn.nextDouble()<0.5){                glycoPheno=MUTANT_GLYCOLYTIC_PHENO;            }            c.Init(false,glycoPheno,false,0.0,0.0);        }    }    void FillCircle(int centerX, int centerY){        int[] startPopSquares= CircleHood(false, 24);        int[] startPopIs=new int[startPopSquares.length/2];        //int nNewCells=this.FindEmptyNeighbors(startPopSquares,startPopIs,centerX,centerY);        int nNewCells=this.HoodToEmptyIs(startPopSquares,startPopIs,centerX,centerY);        for (int i = 0; i < nNewCells; i++) {                Cell c = NewAgentSQ(startPopIs[i]);                double glycoPheno = NORMAL_GLYCOLYTIC_PHENO;                if (rn.nextDouble() < 0.5) {                //if ( i % 2 == 0){                    glycoPheno = MUTANT_GLYCOLYTIC_PHENO;}                //}                c.Init(false, glycoPheno, false, 0.0, 0.0);        }    }    double Blood_TurnOnOff_O2(){        double VESSEL_O2;        VESSEL_O2 = VESSEL_O2_VAL;                 // [mmol/L]        if (GetTick()>=1000 && GetTick()< 110) {            VESSEL_O2 = 0.0f;                 // [mmol/L]        }        return VESSEL_O2;    }    double Blood_TurnOnOff_GLU(){        double VESSEL_GLU;        VESSEL_GLU = VESSEL_GLU_VAL;        if (GetTick()>=1000 && GetTick()< 110) {            VESSEL_GLU = 0.0f;        }        return VESSEL_GLU;    }    double BloodTurnOnOff_Proton(){        double VESSEL_PROTON;        VESSEL_PROTON = PhToProtons(VESSEL_PH_VAL);        return VESSEL_PROTON;    }    int DiffToSteadyState(double steadyStateReq){        double diff=Double.MAX_VALUE;        int ct=0;        while(diff>steadyStateReq){            diff=DiffStepSteadyState();            ct++;        }        return ct;    }    double DiffStepSteadyState(){        O2.Diffusion(0.091,0);//0.091        Glu.Diffusion(0.025,0);        proton.Diffusion(0.054,0);        for (Cell c : this) {            c.DiffStep();        }        double ret=O2.MaxDifSwap()+Glu.MaxDifSwap()+proton.MaxDifSwap();        return ret;    }    void DiffStep(){        //trt.TickPause(tickRate);        O2.Diffusion(0.091,0);//0.091        Glu.Diffusion(0.025,0);        proton.Diffusion(0.054,0);        for (Cell c : this) {            c.DiffStep();        }        //IncTick();    }    void Step(){        trt.TickPause(STEP_PAUSE);        DiffToSteadyState(STEADY_STATE_REQ);        //Metabolism();       // System.out.println(GetTick()+", "+ GetPop()  );        //System.out.println(popTumor);        for (Cell c : this) {            c.Step();        }        out3.Write(GetTick() + "," +GetPop() +"\n");        //IncTick();        CleanShuffInc(rn);        vis.Draw();    }    public static void main(String[] args) {        Tissue t=new Tissue(SIDE_LEN,SIDE_LEN,"O2.csv", "Glucose.csv", "Population.csv");        for (int i = 0; i < TIMESTEPS; i++) {            t.Step();        }        t.out.Close();        t.atpTestOut.Close();        t.vis.win.Dispose();    }}class TissueVis{    Tissue drawMe;    GuiWindow win;    GuiGridVis visCells;    GuiGridVis visO2;    float[] colorScratch=new float[3];    GuiGridVis visGlu;    GuiGridVis visProton;    GuiLabel timeLbl;    GuiLabel popTotLbl;    GuiLabel popTumorLbl;    GuiLabel popNormalLbl;    public TissueVis(Tissue drawMe){        this.drawMe=drawMe;        win=new GuiWindow("KroghModel",true);        timeLbl=new GuiLabel("Tick:                      -");        popTotLbl=new GuiLabel("Total Pop:                 -");        popTumorLbl=new GuiLabel("Tumor Pop:                 -");        popNormalLbl=new GuiLabel("Normal Pop:                -");        visCells=new GuiGridVis(drawMe.xDim,drawMe.yDim,VIS_SCALE,1,10);        visO2=new GuiGridVis(drawMe.xDim,drawMe.yDim,VIS_SCALE,1,10);        visGlu=new GuiGridVis(drawMe.xDim,drawMe.yDim,VIS_SCALE,1,10);        visProton=new GuiGridVis(drawMe.xDim,drawMe.yDim,VIS_SCALE,1,10);        win.AddCol(0, popTotLbl);        win.AddCol(0, popTumorLbl);        win.AddCol(0, popNormalLbl);        win.AddCol(0, timeLbl);        win.AddCol(1, new GuiLabel("Tissue"));        win.AddCol(2, new GuiLabel("Oxygen"));        win.AddCol(3, new GuiLabel("Glucose"));        win.AddCol(4, new GuiLabel("proton"));        win.AddCol(1, visCells);        win.AddCol(2, visO2);        win.AddCol(3, visGlu);        win.AddCol(4, visProton);        win.RunGui();    }    public void Draw(){        //set labels        popTotLbl.SetText("Total Pop: "+(drawMe.popNormal+drawMe.popTumor));        popTumorLbl.SetText("Glycol Pop: "+drawMe.popTumor);        popNormalLbl.SetText("Normal Pop: "+drawMe.popNormal);        timeLbl.SetText("Tick: "+drawMe.GetTick());        //draw cells        AgentToColorInt<Cell> colorFn = (Cell drawMe)->{            if(drawMe.IsVessel()){                return RGB(0.8,0.1,0.2);            }            if(drawMe.IsMut()){                return RGB(0.39,0.58,0.93);            }            if(drawMe.IsNecrotic()){                return RGB(0.3,0.3,0.3);            }            return RGB(0.88,1,1);        };        visCells.DrawAgents(drawMe, colorFn, RGB((double) 0, (double) 0, (double) 0));        //draw diffusible        visO2.DrawGridDiff(drawMe.O2,(val2)->{            return HeatMapRBG(RescaleMinToMax(val2, (double) 0, 0.056));        });        visGlu.DrawGridDiff(drawMe.Glu,(val1)->{            return HeatMapRBG(RescaleMinToMax(val1, (double) 0, 5.0));        });        visProton.DrawGridDiff(drawMe.proton,(double val)->{            double scaled= Bound(Rescale0to1(ProtonsToPh(val),6,7.4),0,1);            return Utils.HeatMapRGB(scaled);        });    }}