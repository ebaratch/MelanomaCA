package Models.KroghModelAcid;import Framework.Extensions.SphericalAgent2D;import Framework.GridsAndAgents.AgentGrid2D;import Framework.GridsAndAgents.PDEGrid2D;import Framework.Gui.GuiGridVis;import Framework.Gui.GuiLabel;import Framework.Gui.GuiWindow;import Framework.Gui.Vis2DOpenGL;import Framework.Interfaces.AgentToColorInt;import Framework.Tools.FileIO;import Framework.Gui.TickTimer;import Framework.Utils;import java.util.ArrayList;import java.util.Random;import static Models.KroghModelAcid.Tissue.*;import static Framework.Utils.*;/** * Created by Rafael on 8/1/2017. */class Cell extends SphericalAgent2D<Cell,Tissue> {    double vesselO2;    double vesselGlu;    double vesselProton;    double necro;    double O2Consumed;    double GluConsumed;    double CellATPlevel;    double ProtonProduced;    double cycleTime;    double phenoFlipProb;    double TimeRightNow;    double O2ConsumedProl;    double ATPdAcidDependent;    double death_decision;    double timestepATP;    double birth_decision;    double clock;    double nat_death_prob;    double MaxGluRate;    double assignedPheno;    double ATPconsumed;    double ATPforCellCycle;    double glycoPhenotype;    double maxATP;    int IDIE;    double OnOff;    double atp;    double currentATP;    double death_prob;    double CellCycleTime;    double birth_thr;    double O2Conc;    double GluConc;    double cellCycleReq;    double CollectedATP;    double ResistAcid;    double ATPqAcidDependent;    double forceSum;    double OverlapResponse(double overlap){        if(overlap>0){ return Math.pow(overlap*G().FORCE_CONST,G().FORCE_EXP); }        //if(overlap<0){ return Math.abs(overlap*G().FORCE_CONST); }        return 0;    }    void Init(boolean isVessel,double glycoPhenotype, boolean isNecrotic, double currentATP, double cellCycleReq, double clock, double phenoFlipProb){        if(isVessel){            this.vesselO2 = G().Blood_TurnOnOff_O2();            this.vesselGlu = G().Blood_TurnOnOff_GLU();            this.vesselProton = G().BloodTurnOnOhh_Proton();            this.radius=G().VESSEL_RAD;            this.phenoFlipProb = -1;            this.necro=-1;            this.clock = -1;            this.assignedPheno = -1;        }        else if(isNecrotic){            this.radius=G().STARTING_CELL_RAD;            this.vesselO2 =-1;            this.vesselGlu=-1;            this.vesselProton=-1;            this.necro = 100;            this.phenoFlipProb = -1;            this.clock = clock;            G().popNecro++;        }        else{            this.radius=G().STARTING_CELL_RAD;            this.glycoPhenotype=glycoPhenotype;            this.vesselO2 =-1;            this.vesselGlu=-1;            this.vesselProton =-1;            this.necro =-1;            this.ATPforCellCycle=0;            this.currentATP = currentATP;            this.clock = clock;            this.phenoFlipProb = phenoFlipProb;            this.cellCycleReq= (G().AVG_CELL_CYCLE + G().rn.nextDouble()*G().AVG_CELL_CYCLE)*G().DIFFs_IN_DAY*G().ATP_TARGET;       // time_in_days*to_sec*atp_target_per_diff_step            PlusCell();        }    }    boolean IsMut() {        if (glycoPhenotype != G().NORMAL_GLYCOLYTIC_PHENO){            return true;        }        else{            return false;        }    }    void ConvertToNecrotic(){        clock = 0;        this.Init(false, glycoPhenotype,true,0,cellCycleReq, clock, 0.0);    }    void ApoptoticDeath(){        Dispose();    }    boolean IsVessel(){        return vesselO2 != -1;    }    boolean IsNecrotic(){        return necro != -1;    }    void PlusCell(){        if (IsMut()){            G().popTumor++;        }        else{            G().popNormal++;        }    }    void MinusCell(){        if (IsMut()){            G().popTumor--;        }        else{            G().popNormal--;        }    }    void CalcForce() {        if (!IsVessel()) {            forceSum=SumForces( G().VESSEL_RAD+G().STARTING_CELL_RAD + G().CELL_CYCLE_END_EXTRA_RAD, G().forceCalcScratch, this::OverlapResponse);            PullCellToVessel(G().MAG_FORCE);        }    }    void CellMove(){        ApplyFriction(G().FRICTION);        ForceMove();        double direction;    }    void PullCellToVessel(double forceMag){        double xComp=G().xDim/2.0-Xpt();        double yComp=G().yDim/2.0-Ypt();        double norm=Norm(xComp,yComp);        xVel+=(xComp/norm)*forceMag;        yVel+=(yComp/norm)*forceMag;    }    double PhenoFlip(){        double FlipProb = G().rn.nextDouble();        double OldPheno = glycoPhenotype;        if (glycoPhenotype == G().NORMAL_GLYCOLYTIC_PHENO){            if (FlipProb <= phenoFlipProb) {                glycoPhenotype = G().MUTANT_GLYCOLYTIC_PHENO;            }        }        else if (glycoPhenotype != G().NORMAL_GLYCOLYTIC_PHENO) {            if (FlipProb <= phenoFlipProb) {                glycoPhenotype = G().NORMAL_GLYCOLYTIC_PHENO;            }        }        PhenoFlipProb();        return glycoPhenotype;    }    boolean PoorCondDeathProb() {        death_decision = G().rn.nextDouble();        if (death_decision <= G().POOR_COND_DEATH_RATE) {            return true;        }        else{            return false;        }    }    boolean PoorCondDeathProb1() {        death_decision = G().rn.nextDouble();        if (death_decision <= death_prob) {            return true;        }        else{            return false;        }    }    double InitPhenoFlip() {        double o2_val = G().O2.Get(Isq());        if (o2_val/G().VESSEL_O2_VAL < 0.0001 ){            return glycoPhenotype = G().MUTANT_GLYCOLYTIC_PHENO;        }        else{ return glycoPhenotype = G().NORMAL_GLYCOLYTIC_PHENO;}    }    void CellDiffStep(){        //vessel production        if(IsVessel()) {            if (G().Blood_TurnOnOff_O2() != 0){                G().O2.Set(Isq(),G().Blood_TurnOnOff_O2());                G().Glu.Set(Isq(),G().Blood_TurnOnOff_GLU());                G().proton.Set(Isq(),G().BloodTurnOnOhh_Proton());            }        }        //cell consumption        else {            if (!IsNecrotic()) {                double O2Conc = G().O2.Get(Isq());                double GluConc = G().Glu.Get(Isq());                double PHConc = G().proton.Get(Isq());                O2Consumed = -MichaelisMenten(O2Conc, G().O2_MAX_RATE, G().O2_HALF_MAX);                MaxGluRate = glycoPhenotype * G().ATP_TARGET / 2.0f + 27.0f * (O2Consumed) / 10.0f;                if (MaxGluRate < 0) {                    throw new IllegalStateException("MaxGlu< < 0");                }                GluConsumed = -MichaelisMenten(GluConc, MaxGluRate, G().GLU_HALF_MAX);                ProtonProduced = G().PROTON_BUFF_COEF * (29.0f * (glycoPhenotype * G().O2_MAX_RATE + O2Consumed) / 5.0f);                G().O2.Add(Isq(), O2Consumed);                G().Glu.Add(Isq(), GluConsumed);                G().proton.Add(Isq(), ProtonProduced);                if (G().O2.Get(Isq()) < 0) {                    throw new IllegalStateException("Cell consuming more O2 than exists");                }            }            else{                //System.out.println("I'm necrotic");            }        }    }    double AcidResistance(){        if(IsMut()){            ResistAcid = G().MUTANT_ACID_RESIST;        }        else{            ResistAcid = G().NORMAL_ACID_RESIST;        }        return ResistAcid;    }    void CheckForDeath(double pH){        double doIdie = G().rn.nextDouble();        if (Alive() && doIdie <= G().NORMAL_DEATH_RATE) {            ApoptoticDeath();            MinusCell();            return;        }        AcidResistance();        if (Alive() && pH < ResistAcid && PoorCondDeathProb()) {            ApoptoticDeath();            MinusCell();            return;        }    }    double PhenoFlipProb(){        if (phenoFlipProb < G().MAX_PHENO_PROB){            phenoFlipProb = phenoFlipProb + 0.01;        }        else{            phenoFlipProb = G().MAX_PHENO_PROB;        }        return phenoFlipProb;    }    double ATP_COSTS_Divide_Req() {        if (IsMut()) {            return cellCycleReq*4;//*2.0;        }        else{            return cellCycleReq;}    }    void CellDivStep() {        if (!IsVessel() && !IsNecrotic()){            if (G().GetTick() == 1){                //InitPhenoFlip();            }            double pH = ProtonsToPh(G().proton.Get(Isq()));            CheckForDeath(pH);            double atp_per_timestep = -(2.0f * GluConsumed + 27.0f * O2Consumed / 5.0f)*G().DIFFs_IN_TIME_STEP;            currentATP += atp_per_timestep;            //need to update cyclereq for costs            double normATP = atp_per_timestep/G().ATP_TARGET_PER_DIFFSTEP;            double normTotalATP = currentATP/ATP_COSTS_Divide_Req();            //System.out.println(normTotalATP + "," + normATP + "," + glycoPhenotype + "," + ATP_COSTS_Divide_Req() + "," + currentATP);            if (Alive()){                if (normATP <= G().ATP_DEATH_THR && PoorCondDeathProb()) {                    ConvertToNecrotic();                    MinusCell();                }                else if(normTotalATP>= G().ATP_QUIES_THR && forceSum < 0.15){                    Cell child = Divide(radius * 2.0 / 3, G().divCoordScratch, G().rn);                    Init(false, glycoPhenotype, false,0.0,0.,0.0, phenoFlipProb);                    //PhenoFlip();                    currentATP = 0;                    child.Init(false, glycoPhenotype, false,0.0,0.0,0.0, phenoFlipProb);                    PlusCell();                    //System.out.println("DIVIDE " + glycoPhenotype + "," + phenoFlipProb);                }            }            clock++;        }        else if (IsVessel()) {            //this.vesselO2 = G().Blood_TurnOnOff_O2();        }        else if (IsNecrotic()) {            clock ++;            double necroProb = G().rn.nextDouble();            if (necroProb < G().NECROTIC_TURNOVER) {                Dispose();                G().popNecro--;            }        }    }    void CellDivForDiffStep() {        if (!IsVessel() && !IsNecrotic()){            double pH = ProtonsToPh(G().proton.Get(Isq()));            double timestepATP1= -(2.0f * GluConsumed + 27.0f * O2Consumed / 5.0f);            double resultingATP = timestepATP1/G().ATP_TARGET;            if (G().start_val_d == 0){                //death_prob = 1.6e-7;            }            death_prob = G().POOR_COND_DEATH_RATE1;            if (resultingATP <= G().ATP_DEATH_THR && PoorCondDeathProb1()) {                ConvertToNecrotic();                //System.out.println("I'm here " + glycoPhenotype);                MinusCell();            }            //System.out.println(death_prob);            //death_prob += 1.6e-7;        }        else if (IsVessel()) {            if (G().Blood_TurnOnOff_O2() != 0){                G().proton.Set(Isq(),G().BloodTurnOnOhh_Proton());            }        }        else if (IsNecrotic()) {            double necroProb = G().rn.nextDouble();            if (necroProb <= G().NECROTIC_TURNOVER*0.0001) {                Dispose();                G().popNecro--;            }        }    }}public class Tissue extends AgentGrid2D<Cell> {    FileIO out;    //FileIO out1;    //FileIO out2;    //GRID SPACING    static int SIDE_LEN=40;    static int TIMESTEPS=100;    static int STEP_PAUSE= 1;//(int) Math.round((16*60*60)/0.6);    final long tickRate = 0;    static int VIS_SCALE=10;    //TIMES    public double DIFF_TIME_STEP = 0.02f;       //[s]    double TIME_STEP = 0.1;                        // [days]    double DIFFs_IN_TIME_STEP = 432000.0f;    double AVG_CELL_CYCLE = 0.8;    public static int TIMESTEPS_IN_CYCLE = 1000;//720000; 180000;    double DIFFs_IN_DAY = 4320000;    TickTimer trt;    //OXYGEN CONSUMPTION    double O2_MAX_RATE =0.012f * DIFF_TIME_STEP;       // [mmol/L]    double O2_HALF_MAX =0.005f;                   // [mmol/L]    double CELL_CONSUMPTION_2_DIVIDE=0.05f;                         // [mmol/L]    //O2 CONCENTRATION CHECKPOINTS    double NECROSIS_O2 =0.001f;                                    // [mmol/L]    double Q_THRESHOLD = 0.0056f;                                  // [mmol/L]    double VESSEL_O2_VAL = 0.056f;                                      // [mmol/L]    //GLUCOSE VALUES    double GLU_HALF_MAX = 0.04f;                                    // [mmol/L]    double GLU_DIFF = 0.1f;    double VESSEL_GLU_VAL = 5.0f;                                       // [mmol/L]    double ATP_TARGET = 29.0f* O2_MAX_RATE /5.0f;    double ATP_TARGET_PER_DIFFSTEP = ATP_TARGET *DIFFs_IN_TIME_STEP;    //ACID    double PROTON_BUFF_COEF =0.2e-4;    double NORMAL_ACID_RESIST = 6.6f;                       // [pH]    double VESSEL_PH_VAL = 7.4f;                             // [pH]    double MUTANT_ACID_RESIST = 6.1f;    //PHENOTYPES    double MUTANT_GLYCOLYTIC_PHENO=15;    double NORMAL_GLYCOLYTIC_PHENO=1;    double[] PHENO_CHOICE = {NORMAL_GLYCOLYTIC_PHENO, MUTANT_GLYCOLYTIC_PHENO};    //ATP THRESHOLDS    double ATP_DEATH_THR = 0.3;    double ATP_QUIES_THR = 0.8;    //MOVING CELLS    double STARTING_CELL_RAD=0.5;    double VESSEL_RAD=STARTING_CELL_RAD;    double CELL_CYCLE_END_EXTRA_RAD=STARTING_CELL_RAD*(Math.sqrt(2.0/Math.PI)/Math.sqrt(1.0/Math.PI)-1);    double FRICTION=0.2;    double FORCE_CONST=0.7;//*FRICTION;    double FORCE_EXP=1;    double CONTACT_INHIB_MAX=1.0;    double STARTING_SPACING=0.2;    double MAG_FORCE = 0.01;    int ROUNDS_OF_CELL_PUSH=5;    double maxCellMove = 0.01;    //COUNTING    double popNormal=0;    double popTumor=0;    double popNecro=0;    //DEATH PROBABILITIES    double NORMAL_DEATH_RATE = 0.001f;                  //[per cell cycle]    double POOR_COND_DEATH_RATE = 0.14f;    double POOR_COND_DEATH_RATE1 = 1.e-3f;    double NECROTIC_TURNOVER = 5.0e-1f;    double TUCP;    double NOCP;    double NECP;    double GLYC_TRANSITION_PROB;    double MAX_PHENO_PROB = 0.5;    double NORM_TRANSITION_PROB = 0.1;    double OnOff;    double SWITCH_TIME;// = 4000;    double DT;// = 4;    FileIO atpTestOut;    double VESSEL_O2;    double VESSEL_GLU;    double VESSEL_PROTON;    double start_val_d;    double MyTick = 0;    double OCCLUSION;    double INTERVAL;    double STEADY_STATE_REQ=0.00001;    float[] circlePts=GenCirclePoints(1,15);    int TURN_OFF_TICK = 100;    ArrayList<Cell> forceCalcScratch;    double[]divCoordScratch=new double[2];    PDEGrid2D O2;    PDEGrid2D Glu;    PDEGrid2D proton;    Random rn;    TissueVis vis;    int[] mooreHood=MooreHood(false);    int[] validDivIs=new int[mooreHood.length/2];    public Tissue(int x,int y,String outFileName,boolean visOn){        super(x,y,Cell.class);        atpTestOut=new FileIO("atpTestOut.csv","w");        out=new FileIO(outFileName,"w");        out.Write("TickTime,TotalPop,NormalPop,GlycoPop,NecroPop\n");        //out1=new FileIO(outFile1,"w");        //out2=new FileIO(outFile2,"w");        forceCalcScratch=new ArrayList<>();        int[] startPopSquares= CircleHood(false,15);        //int[] startPopIs=new int[startPopSquares.length/2];        //this.HoodToIs(startPopSquares,startPopIs,xDim/2,yDim/2);        O2=new PDEGrid2D(xDim,yDim);        //O2.SetAllCurr(VESSEL_O2_VAL);        Glu = new PDEGrid2D(xDim, yDim);        //Glu.SetAllCurr(VESSEL_GLU_VAL);        proton = new PDEGrid2D(xDim, yDim);       // proton.SetAllCurr(PhToProtons(VESSEL_PH_VAL));        rn=new Random();        if(visOn) {            vis = new TissueVis(this);        }        trt=new TickTimer();        CreateVesselAndCells(xDim/2.0,yDim/2.0,startPopSquares,STARTING_SPACING,0);        //CreateVesselAndCells(xDim*2/6.0,yDim*2/6.0,startPopSquares,STARTING_SPACING,0);        //CreateVesselAndCells(xDim*4/6.0,yDim*2/6.0,startPopSquares,STARTING_SPACING,0);        //CreateVesselAndCells(xDim*4/6.0,yDim*4/6.0,startPopSquares,STARTING_SPACING,0);        //CreateVesselAndCells(xDim*2/6.0,yDim*4/6.0,startPopSquares,STARTING_SPACING,0);        //CreateVesselAndCells(xDim*5/6.0,yDim*5/6.0,startPopSquares,STARTING_SPACING,0);        //CreateVesselAndCells(xDim*1/6.0,yDim*5/6.0,startPopSquares,STARTING_SPACING,0);        //CreateVesselAndCells(xDim*3/6.0,yDim*5/6.0,startPopSquares,STARTING_SPACING,0);        //CreateVesselAndCells(xDim*5/6.0,yDim*3/6.0,startPopSquares,STARTING_SPACING,0);        //CreateVesselAndCells(xDim*5/6.0,yDim*1/6.0,startPopSquares,STARTING_SPACING,0);        IncTick();        CellForceMoveAllSteadyState(maxCellMove);        if (GetTick() == SWITCH_TIME ){            DiffStep();        }        else{            DiffToSteadyState(STEADY_STATE_REQ);        }    }    public int CreateVesselAndCells(double centerX,double centerY,int[]startingLocations,double startingDensity,double probMut) {        Cell firstVessel = NewAgentPT(centerX, centerY);        int cellCt=0;        firstVessel.Init(true, 0.0, false,0.0,0.0,0,0.0);        for (int i = 0; i < startingLocations.length; i += 2) {            double xStart = startingLocations[i] * startingDensity + centerX;            double yStart = startingLocations[i + 1] * startingDensity + centerY;            double vesselOverlapRad = (VESSEL_RAD + STARTING_CELL_RAD);            if (DistSquared(xStart, yStart, xDim / 2.0, yDim / 2.0) > vesselOverlapRad * vesselOverlapRad) {                Cell c = NewAgentPT(xStart, yStart);                double glycoPheno = NORMAL_GLYCOLYTIC_PHENO;                if (rn.nextDouble() < probMut) {                    glycoPheno = MUTANT_GLYCOLYTIC_PHENO;                }                c.Init(false, glycoPheno, false, 0.0, 0.0,0, NORM_TRANSITION_PROB);                cellCt++;            }        }        return cellCt;    }    //double GetRunTime(){    //    return GetTick()*CELL_CYCLE_TIME;    //}    double Blood_TurnOnOff_O2(){        double dec;        VESSEL_O2 = VESSEL_O2_VAL;                 // [mmol/L]        if (OCCLUSION == 1) {            VESSEL_O2 = VESSEL_O2_VAL*Math.abs(Math.sin(GetTick()))*0;        }        //else if(GetTick()>=TIMESTEPS_IN_CYCLE+SWITCH_TIME && GetTick()<TIMESTEPS_IN_CYCLE+SWITCH_TIME+DT*TIMESTEPS_IN_CYCLE){         //   VESSEL_O2 = VESSEL_O2_VAL*Math.abs(Math.sin(GetTick()))*0;        //}        return VESSEL_O2;    }    double Blood_TurnOnOff_GLU(){        double dec;        VESSEL_GLU = VESSEL_GLU_VAL;                 // [mmol/L]        if (OCCLUSION == 1) {            VESSEL_GLU = VESSEL_GLU_VAL*Math.abs(Math.sin(GetTick()))*0;        }        //else if(GetTick()>=TIMESTEPS_IN_CYCLE+SWITCH_TIME && GetTick()<TIMESTEPS_IN_CYCLE+SWITCH_TIME+DT*TIMESTEPS_IN_CYCLE){        //    VESSEL_GLU = VESSEL_GLU_VAL*Math.abs(Math.sin(GetTick()))*0;        }        return VESSEL_GLU;    }    double BloodTurnOnOhh_Proton(){        double dec;        VESSEL_PROTON = PhToProtons(VESSEL_PH_VAL);                 // [mmol/L]        if (OCCLUSION == 1) {            VESSEL_PROTON = PhToProtons(VESSEL_PH_VAL)*Math.abs(Math.sin(GetTick()))*0;        }        return VESSEL_PROTON;    }    int DiffToSteadyState(double steadyStateReq){        double diff=Double.MAX_VALUE;        int ct=0;        while(diff>steadyStateReq){            diff=DiffStepSteadyState();            ct++;        }        return ct;    }    double DiffStepSteadyState(){        //trt.TickPause(tickRate);        O2.Diffusion(0.091,0);//0.091        Glu.Diffusion(0.025,0);        proton.Diffusion(0.054,0);        for (Cell c : this) {            c.CellDiffStep();        }        double ret=O2.MaxDifSwap()+Glu.MaxDifSwap()+proton.MaxDifSwap();        return ret;    }    void DiffStep(){        O2.Diffusion(0.091,0);//0.091        Glu.Diffusion(0.025,0);        proton.Diffusion(0.054,0);        for (Cell c : this) {            c.CellDiffStep();        }    }    void CellDivStepAll(){        for(Cell c:this){            c.CellDivStep();        }    }    void CellDivDiffStepAll(){        for(Cell c:this){            c.CellDivForDiffStep();        }    }    void CellForceMoveAll(){        for(Cell c:this){            c.CalcForce();        }        for(Cell c:this){            c.CellMove();        }    }    int CellForceMoveAllSteadyState(double maxDelta){        int ct=0;        double maxDeltaSq=maxDelta*maxDelta;        while(true) {            double maxForceMagSq=0;            for (Cell c : this) {                c.CalcForce();                maxForceMagSq = Math.max(c.xVel * c.xVel + c.yVel * c.yVel, maxForceMagSq);              }            //System.out.println(Math.sqrt(maxForceMagSq));            if(maxForceMagSq<maxDeltaSq){                return ct;            }            for(Cell c:this){                c.CellMove();            }        }    }    void CellCounter(){        TUCP = 0;        NOCP = 0;        NECP = 0;        for(Cell c:this){            if (c.glycoPhenotype != NORMAL_GLYCOLYTIC_PHENO && !c.IsNecrotic()){                TUCP++;            }            else if(c.glycoPhenotype == NORMAL_GLYCOLYTIC_PHENO && !c.IsNecrotic()){                NOCP++;            }            else if(c.IsNecrotic()){                NECP++;            }        }        System.out.println(GetPop());        out.Write(GetTick()+", " + MyTick + ", "  + GetPop() + ", " + NOCP + ", " + TUCP + "," + NECP+"\n");        //System.out.println(GetTick()+", "+ GetPop() + ", " + NOCP + TUCP);    }    void Step(){        trt.TickPause(STEP_PAUSE);        //if (GetTick() >= SWITCH_TIME && GetTick() < SWITCH_TIME + DT*TIMESTEPS_IN_CYCLE){        if (GetTick() >= SWITCH_TIME && GetTick() % INTERVAL == 0) {            OCCLUSION = 1;            //System.out.println("Occl " );            for (int i = 0; i < DT; i++) {                DiffStep();                CellDivDiffStepAll();                IncTick();                CellForceMoveAllSteadyState(maxCellMove);                CleanAgents();                ShuffleAgents(rn);                MyTick = MyTick + DIFF_TIME_STEP;                if (vis != null) {                    vis.Draw();                    vis.Draw2d();                }            }            //}            //else {            OCCLUSION = 0;            DiffToSteadyState(STEADY_STATE_REQ);            CellDivStepAll();            CellCounter();            IncTick();            CellForceMoveAllSteadyState(maxCellMove);            CleanAgents();            ShuffleAgents(rn);            MyTick = MyTick + 17280.0f;            if (vis != null) {                vis.Draw();                vis.Draw2d();            }        }        else{            OCCLUSION = 0;            DiffToSteadyState(STEADY_STATE_REQ);            CellDivStepAll();            CellCounter();            IncTick();            CellForceMoveAllSteadyState(maxCellMove);            CleanAgents();            ShuffleAgents(rn);            MyTick = MyTick + 17280.0f;            if(vis!=null) {                vis.Draw();                vis.Draw2d();            }        }    }    //switch time = when the oscillation begin [in time steps]    //DT = duration of occlusion [in diff steps]    //INTERVAL = interval of occlusion events [in time steps]    static RunOutput RunModel(double SWITCH_TIME,double DT,double NORM_TRANSITION_PROB,double GLYC_TRANSITION_PROB,String outFileName,boolean visOn, double INTERVAL){        //create and parameterize tissue for run        Tissue t=new Tissue(SIDE_LEN,SIDE_LEN,outFileName,visOn);        t.SWITCH_TIME=SWITCH_TIME;        t.DT=DT;        t.NORM_TRANSITION_PROB=NORM_TRANSITION_PROB;        t.GLYC_TRANSITION_PROB=GLYC_TRANSITION_PROB;        t.INTERVAL = INTERVAL;        t.out.Write("Duration = " + DT + ", Interval = " + INTERVAL + ", Sensitivity = " + t.POOR_COND_DEATH_RATE1);        RunOutput ret=new RunOutput(t);        double u = 0;        for (int i = 0; i < TIMESTEPS; i++) {            t.Step();            u++;            //System.out.println(u);        }        t.atpTestOut.Close();        ret.UpdateData(t);        ret.FinalCalc();        t.out.Close();        t.vis.SaveOffLatticeScreenShot("test.png");        if(t.vis!=null){            t.vis.win.Dispose();        }        t.out.Close();        return ret;    }    double CalcGlycProp(){        return TUCP*1.0/(TUCP+NOCP);    }    public static void main(String[] args) {        //ArrayList<RunOutput> outputs=MultiThread(3,8,(int iThread)->{         //   System.out.println("Started Thread "+iThread);        //    Random rn=new Random();       ///     double GLYC_TRANSITION_PROB=rn.nextDouble()*0.5;       //     double NORM_TRANSITION_PROB=rn.nextDouble()*0.5;        //    double DURATION = 500 + 250*iThread;         //   double INTERVAL = 20 + 10*iThread;        //    RunOutput ret= RunModel(100,DURATION,NORM_TRANSITION_PROB,GLYC_TRANSITION_PROB,"Normal-"+iThread+".csv",false, INTERVAL);        //    System.out.println("Finished Thread "+iThread);        //    return ret;        //});        //FileIO allOut=new FileIO("AllRuns.csv","w");        RunOutput ret= RunModel(10000,500,0.1,0.1,"OscOccl-Norm-1_"+"out.csv",true, 20);        //RunOutput ret= RunModel(500,4,0.01,0.1,"Occl500-4_0.01_0.1"+"out.csv",true);        //RunOutput ret= RunModel(500,4,0.1,0.1,"Occl500-4_0.1_0.1"+"out.csv",true);        //RunOutput ret= RunModel(3000,4,0.2,0.2,"NoOccl_0.2_0.2"+"out.csv",true);        //allOut.Write("SwitchTime,DT,NormTranstionProb,GlycTransitionProb,GlycProp\n");        //for (RunOutput out:outputs) {        //    allOut.Write(out.SWITCH_TIME+","+out.DT+","+out.NORM_TRANSITION_PROB+","+out.GLYC_TRANSITION_PROB+","+out.GlycProp+"\n");        //}        //allOut.Close();    }}class RunOutput{    int nSamples;    double GlycProp;    double SWITCH_TIME;    double DT;    double NORM_TRANSITION_PROB;    double GLYC_TRANSITION_PROB;    public RunOutput(Tissue t){        SWITCH_TIME=t.SWITCH_TIME;        DT=t.DT;        NORM_TRANSITION_PROB=t.NORM_TRANSITION_PROB;        GLYC_TRANSITION_PROB=t.GLYC_TRANSITION_PROB;    }    void UpdateData(Tissue t){        nSamples++;        GlycProp+=t.CalcGlycProp();    }    void FinalCalc(){        GlycProp/=nSamples;    }}class TissueVis{    Tissue drawMe;    GuiWindow win;    GuiGridVis visCells;    GuiGridVis visO2;    GuiGridVis visGlu;    GuiGridVis visProton;    GuiLabel timeLbl;    GuiLabel popTotLbl;    GuiLabel popTumorLbl;    GuiLabel popNormalLbl;    Vis2DOpenGL vis2D;    float[] colorScratch=new float[3];    public TissueVis(Tissue drawMe){        this.drawMe=drawMe;        win=new GuiWindow("KroghModel",true);        timeLbl=new GuiLabel("Tick:                      -");        popTotLbl=new GuiLabel("Total Pop:                 -");        popTumorLbl=new GuiLabel("Tumor Pop:                 -");        popNormalLbl=new GuiLabel("Normal Pop:                -");        visCells=new GuiGridVis(drawMe.xDim,drawMe.yDim,VIS_SCALE,1,10);        visO2=new GuiGridVis(drawMe.xDim,drawMe.yDim,VIS_SCALE,1,10);        visGlu=new GuiGridVis(drawMe.xDim,drawMe.yDim,VIS_SCALE,1,10);        visProton=new GuiGridVis(drawMe.xDim,drawMe.yDim,VIS_SCALE,1,10);        win.AddCol(0, popTotLbl);        win.AddCol(0, popTumorLbl);        win.AddCol(0, popNormalLbl);        win.AddCol(0, timeLbl);        win.AddCol(1, new GuiLabel("Tissue"));        win.AddCol(2, new GuiLabel("Oxygen"));        win.AddCol(3, new GuiLabel("Glucose"));        win.AddCol(4, new GuiLabel("pH"));        win.AddCol(1, visCells);        win.AddCol(2, visO2);        win.AddCol(3, visGlu);        win.AddCol(4, visProton);        win.RunGui();        vis2D=new Vis2DOpenGL("Cell Visualization", 500,500,drawMe.xDim,drawMe.yDim, true);    }    public void SaveOffLatticeScreenShot(String filepath){        vis2D.ToPNG(filepath);    }    public void Draw2d(){        vis2D.Clear(RGB((float) 0, (float) 0, (float) 0));        for (Cell c : drawMe) {            if(c.IsVessel()){                //drawing vessel                vis2D.FanShape((float)c.Xpt(), (float)c.Ypt(), (float)c.radius, drawMe.circlePts,RGB((float)0.8, (float)0.1, (float)0.2));            }            else if(c.IsNecrotic()){                vis2D.FanShape((float)c.Xpt(), (float)c.Ypt(), (float)c.radius, drawMe.circlePts,RGB((float)0.33, (float)0.33, (float)0.33));            }            else if(c.IsMut()){                //drawing tumor cells                if (c.currentATP == 0.0){                    vis2D.FanShape((float)c.Xpt(), (float)c.Ypt(), (float)(c.radius+0.1), drawMe.circlePts,RGB((float)1.0, (float)0.078, (float)0.576));                }                else{                    vis2D.FanShape((float)c.Xpt(), (float)c.Ypt(), (float)(c.radius+0.05), drawMe.circlePts,RGB((float) 0, (float) 0, (float) 0));                }                if(c.glycoPhenotype < 3.0){                    vis2D.FanShape((float)c.Xpt(), (float)c.Ypt(), (float)c.radius, drawMe.circlePts,RGB((float)0.53, (float)0.81, (float)1));                }                else if(c.glycoPhenotype >= 3.0 && c.glycoPhenotype < 6.0){                    vis2D.FanShape((float)c.Xpt(), (float)c.Ypt(), (float)c.radius, drawMe.circlePts,RGB((float)0.39, (float)0.58, (float)0.93));                }                else{                    vis2D.FanShape((float)c.Xpt(), (float)c.Ypt(), (float)c.radius, drawMe.circlePts,RGB((float)0, (float)0, (float)0.55));                }            }            else {                //drawing normal cells                if (c.currentATP == 0.0){                    vis2D.FanShape((float)c.Xpt(), (float)c.Ypt(), (float)(c.radius+0.1), drawMe.circlePts,RGB((float)1.0, (float)0.078, (float)0.576));                }                else{                    vis2D.FanShape((float)c.Xpt(), (float)c.Ypt(), (float)(c.radius+0.05), drawMe.circlePts,RGB((float) 0, (float) 0, (float) 0));                }                vis2D.FanShape((float) c.Xpt(), (float) c.Ypt(), (float)c.radius, drawMe.circlePts,RGB((float)0.88, (float)1, (float)1));            }        }        vis2D.Show();    }    public void Draw(){        //set labels        popTotLbl.SetText("Total Pop: "+(drawMe.popNormal+drawMe.popTumor));        popTumorLbl.SetText("Glycol Pop: "+drawMe.popTumor);        popNormalLbl.SetText("Normal Pop: "+drawMe.popNormal);        timeLbl.SetText("Tick: "+drawMe.GetTick());        //draw cells        AgentToColorInt<Cell> colorFn = (Cell drawMe)->{            if(drawMe.currentATP == 0.0){                return RGB(1,0,0);            }            return RGB(0,0,0);        };        visCells.DrawAgents(drawMe, colorFn, RGB((double) 0, (double) 0, (double) 0));        //draw diffusible        visO2.DrawGridDiff(drawMe.O2,(val2)->{            return HeatMapRBG(RescaleMinToMax(val2, (double) 0, 0.056));        });        visGlu.DrawGridDiff(drawMe.Glu,(val1)->{            return HeatMapRBG(RescaleMinToMax(val1, (double) 0, 3.0));        });        visProton.DrawGridDiff(drawMe.proton,(double val)->{            double scaled= Bound(Rescale0to1(ProtonsToPh(val),6,7.4),0,1);            return Utils.HeatMapRGB(scaled);        });    }}